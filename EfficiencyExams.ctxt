#BlueJ class context
comment0.target=EfficiencyExams
comment0.text=\r\n\ There\ a\ list\ of\ efficiency\ exercises\ from\ exams\ of\ the\ open\ university\ \r\n\ to\ use\ maximaize\ the\ usage\ click\ ctrl\ f\ and\ write\ the\ name\ of\ function\ you\ need\ \r\n\r\n\ @author\ (Or\ saban)\r\n\ @version\ (a\ version\ number\ or\ a\ date)\r\n
comment1.params=arr
comment1.target=int\ findNumber(int[])
comment1.text=\r\n\ \ Efficiency\ Exam\ 2023Bmoed\ 79.\r\n\ \ \r\n\ \ This\ method\ searches\ for\ a\ missing\ number\ in\ a\ sorted\ array\ of\ integers.\r\n\ \ It\ assumes\ that\ the\ array\ contains\ a\ sequence\ of\ consecutive\ integers,\ except\ for\ one\ missing\ number.\r\n\ \ \r\n\ \ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ \ @return\ The\ missing\ number\ if\ found,\ or\ Integer.MIN_VALUE\ if\ not\ found.\r\n
comment10.params=a\ k
comment10.target=int\ longestSequence(int[],\ int)
comment10.text=\r\n\ moed\ 2021B\ moed\ 92\r\n\ \r\n\ This\ method\ finds\ the\ length\ of\ the\ longest\ subarray\ containing\ at\ most\ k\ zeros.\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ k\ The\ maximum\ number\ of\ zeros\ allowed\ in\ the\ subarray.\r\n\ @return\ The\ length\ of\ the\ longest\ subarray.\r\n
comment11.params=a\ k
comment11.target=int\ smallestSub(int[],\ int)
comment11.text=\r\n\ moed\ 2021B\ moed\ 60\r\n\ \r\n\ This\ method\ finds\ the\ length\ of\ the\ smallest\ subarray\ whose\ sum\ is\ less\ than\ or\ equal\ to\ k.\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ k\ The\ target\ sum.\r\n\ @return\ The\ length\ of\ the\ smallest\ subarray.\r\n
comment12.params=a
comment12.target=int\ findMissingIndex(int[])
comment12.text=\r\n\ moed\ 2021\ A\ moed\ 67\r\n\ time\ complexity\ -\ O(log(n))\r\n\ space\ complexity\ -\ O(1)\r\n
comment13.params=arr\ x
comment13.target=boolean\ findAverage(int[],\ double)
comment13.text=\r\n\ moed\ 2021A\ moed\ 85\ corona\r\n\ \r\n\ This\ method\ determines\ whether\ there\ exists\ a\ contiguous\ subarray\ in\ the\ input\ array\ \r\n\ whose\ average\ equals\ a\ given\ value\ x.\r\n\ \ Time\ complexity\ -\ O(n)\r\n\ \ Space\ complexity\ -\ O(1)\r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @param\ x\ The\ target\ average.\r\n\ @return\ True\ if\ there\ exists\ such\ a\ subarray,\ false\ otherwise.\r\n
comment14.params=arr\ k
comment14.target=void\ minimumSubK(int[],\ int)
comment14.text=\r\n\ Finds\ the\ sub-array\ with\ the\ minimum\ sum\ of\ size\ k.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ an\ integer\ k,\ and\ finds\ the\ sub-array\ of\ size\ k\r\n\ with\ the\ minimum\ sum.\ It\ utilizes\ a\ sliding\ window\ algorithm\ to\ efficiently\ compute\ the\r\n\ minimum\ sum\ sub-array.\r\n\r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @param\ k\ The\ size\ of\ the\ sub-array.\r\n
comment15.params=a\ num
comment15.target=void\ printTriplets(int[],\ int)
comment15.text=\r\n\ Prints\ triplets\ from\ the\ given\ array\ whose\ product\ is\ equal\ to\ a\ specified\ number.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ a\ target\ number\ and\ prints\ all\ the\ triplets\r\n\ whose\ product\ is\ equal\ to\ the\ target\ number.\ It\ utilizes\ a\ nested\ loop\ to\ iterate\ over\r\n\ all\ possible\ combinations\ of\ triplets\ in\ the\ array.\r\n\r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ num\ The\ target\ number\ for\ which\ triplets\ are\ searched.\r\n
comment16.params=a
comment16.target=int\ strictlyIncreasing(int[])
comment16.text=\r\n\ Counts\ the\ total\ number\ of\ strictly\ increasing\ subsequences\ in\ the\ array.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ counts\ the\ total\ number\ of\ strictly\ increasing\r\n\ subsequences.\ A\ subsequence\ is\ considered\ strictly\ increasing\ if\ each\ element\ is\ greater\r\n\ than\ the\ previous\ one.\r\n\r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ total\ number\ of\ strictly\ increasing\ subsequences\ in\ the\ array.\r\n
comment17.params=a\ sum
comment17.target=boolean\ findSum(int[],\ int)
comment17.text=\r\n\ Finds\ if\ there\ exists\ a\ pair\ of\ elements\ in\ the\ array\ whose\ sum\ equals\ a\ specified\ value.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ a\ target\ sum\ and\ checks\ if\ there\ exists\ a\ pair\r\n\ of\ elements\ in\ the\ array\ whose\ sum\ is\ equal\ to\ the\ specified\ target\ sum.\ It\ utilizes\ a\r\n\ modified\ version\ of\ the\ Moznayim\ algorithm\ to\ efficiently\ find\ the\ pair.\r\n\r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ sum\ The\ target\ sum\ to\ be\ matched.\r\n\ @return\ true\ if\ a\ pair\ of\ elements\ exists\ whose\ sum\ equals\ the\ target\ sum,\ otherwise\ false.\r\n
comment18.params=arr
comment18.target=int\ findSmallest(int[])
comment18.text=\r\n\ Finds\ the\ smallest\ integer\ that\ cannot\ be\ represented\ as\ a\ sum\ of\ elements\ from\ the\ array.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ finds\ the\ smallest\ positive\ integer\ that\ cannot\ be\r\n\ represented\ as\ a\ sum\ of\ elements\ from\ the\ array.\ It\ iterates\ through\ the\ array,\ updating\ the\r\n\ sum\ of\ elements\ as\ it\ progresses.\ If\ the\ current\ element\ is\ greater\ than\ the\ current\ sum,\ it\r\n\ returns\ the\ sum,\ indicating\ the\ smallest\ integer\ that\ cannot\ be\ represented.\r\n\r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ smallest\ positive\ integer\ that\ cannot\ be\ represented\ as\ a\ sum\ of\ elements\ from\ the\ array.\r\n
comment19.params=a\ b\ x
comment19.target=void\ printClosest(int[],\ int[],\ int)
comment19.text=\r\n\ Prints\ the\ pair\ of\ elements\ from\ two\ arrays\ that\ has\ the\ sum\ closest\ to\ a\ specified\ value.\r\n\r\n\ This\ method\ takes\ two\ arrays\ of\ integers\ and\ a\ target\ value\ and\ prints\ the\ pair\ of\ elements,\r\n\ one\ from\ each\ array,\ whose\ sum\ is\ closest\ to\ the\ specified\ target\ value.\ The\ method\ utilizes\r\n\ a\ two-pointer\ approach\ to\ efficiently\ search\ for\ the\ closest\ pair.\r\n\r\n\ @param\ a\ The\ first\ array\ of\ integers.\r\n\ @param\ b\ The\ second\ array\ of\ integers.\r\n\ @param\ x\ The\ target\ value\ for\ which\ the\ sum\ of\ elements\ should\ be\ closest.\r\n
comment2.params=arr\ num
comment2.target=int\ findSmallestSubarrayLen(int[],\ int)
comment2.text=\r\n\ \ Efficiency\ Exam\ 2023Bmoed\ 83.\r\n\ \ \r\n\ \ This\ method\ finds\ the\ length\ of\ the\ smallest\ subarray\ whose\ sum\ is\ greater\ than\ or\ equal\ to\ a\ given\ number.\r\n\ \ \r\n\ \ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ \ @param\ num\ The\ target\ sum\ to\ find.\r\n\ \ @return\ The\ length\ of\ the\ smallest\ subarray\ whose\ sum\ is\ greater\ than\ or\ equal\ to\ 'num'.\r\n
comment20.params=a
comment20.target=int\ passingCars(int[])
comment20.text=\r\n\ Counts\ the\ number\ of\ passing\ cars\ traveling\ in\ opposite\ directions.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ representing\ cars\ traveling\ in\ a\ single\ direction,\r\n\ where\ 0\ represents\ a\ car\ traveling\ east\ and\ 1\ represents\ a\ car\ traveling\ west.\ It\ calculates\r\n\ the\ total\ number\ of\ pairs\ of\ cars\ that\ pass\ each\ other,\ where\ the\ cars\ traveling\ east\ (0)\r\n\ pass\ those\ traveling\ west\ (1).\ The\ method\ utilizes\ a\ linear\ scan\ of\ the\ array\ to\ efficiently\r\n\ count\ the\ passing\ cars.\r\n\r\n\ @param\ a\ The\ array\ of\ integers\ representing\ cars\ traveling\ in\ a\ single\ direction.\r\n\ @return\ The\ total\ number\ of\ pairs\ of\ passing\ cars.\r\n
comment21.params=a\ x
comment21.target=boolean\ findX(int[],\ int)
comment21.text=\r\n\ Determines\ if\ there\ exist\ two\ adjacent\ elements\ in\ the\ array\ whose\ sum\ equals\ a\ specified\ value.\r\n\r\n\ This\ method\ takes\ an\ array\ of\ integers\ and\ a\ target\ sum\ and\ checks\ if\ there\ exist\ two\ adjacent\r\n\ elements\ in\ the\ array\ whose\ sum\ is\ equal\ to\ the\ specified\ target\ sum.\ It\ utilizes\ a\ binary\ search\r\n\ algorithm\ to\ efficiently\ search\ for\ the\ target\ sum\ in\ the\ array.\r\n\r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ x\ The\ target\ sum\ to\ be\ matched.\r\n\ @return\ true\ if\ there\ exist\ two\ adjacent\ elements\ whose\ sum\ equals\ the\ target\ sum,\ otherwise\ false.\r\n
comment3.params=arr\ target
comment3.target=void\ findSubarray(int[],\ int)
comment3.text=\r\n\ \ Efficiency\ Exam\ 2023Bmoed\ 81.\r\n\ \ \r\n\ \ This\ method\ finds\ the\ subarray\ whose\ elements\ sum\ up\ to\ a\ given\ target\ value.\r\n\ \ \r\n\ \ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ \ @param\ target\ The\ target\ sum\ to\ find.\r\n
comment4.params=arr
comment4.target=int\ findPeak(int[])
comment4.text=\r\n\ moed\ 2023A\ moed\ 72\r\n\ \r\n\ This\ method\ finds\ a\ peak\ element\ in\ a\ given\ array\ using\ binary\ search.\r\n\ A\ peak\ element\ is\ defined\ as\ an\ element\ that\ is\ greater\ than\ or\ equal\ to\ its\ neighbors.\r\n\ \r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ peak\ element\ if\ found,\ otherwise\ -1.\r\n
comment5.params=a\ num
comment5.target=int\ kAlmostSearch(int[],\ int)
comment5.text=\r\n\ 2022B\ moed\ 96\r\n\ \r\n\ This\ method\ performs\ a\ modified\ binary\ search\ to\ find\ a\ target\ number\ in\ an\ array\r\n\ where\ some\ elements\ might\ be\ missing.\ It\ tolerates\ "almost"\ correct\ elements\ (0s).\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @param\ num\ The\ target\ number\ to\ search\ for.\r\n\ @return\ The\ index\ of\ the\ target\ number\ if\ found,\ otherwise\ -1.\r\n
comment6.params=arr
comment6.target=int\ findTriplet(int[])
comment6.text=\r\n\ 2022B\ moed\ 96\r\n\ \r\n\ This\ method\ finds\ the\ maximum\ product\ of\ a\ triplet\ in\ an\ integer\ array.\r\n\ \r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ maximum\ product\ of\ a\ triplet.\r\n\ @timecomplexity\ O(n)\r\n\ @spacecomplexity\ O(1)\r\n
comment7.params=a\ k
comment7.target=void\ sortmod(int[],\ int)
comment7.text=\r\n\ moed\ 2022B\ moed\ 94\r\n\ \r\n\ This\ method\ sorts\ an\ integer\ array\ based\ on\ the\ modulo\ operation\ with\ a\ given\ divisor.\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers\ to\ be\ sorted.\r\n\ @param\ k\ The\ divisor\ used\ for\ the\ modulo\ operation.\r\n\ @timecomplexity\ O(n)\ where\ n\ is\ the\ length\ of\ the\ array.\r\n\ @spacecomplexity\ O(1)\r\n
comment8.params=a
comment8.target=int\ longestSubarray(int[])
comment8.text=\r\n\ moed\ 2022\ A\ moed\ 94\r\n\ \r\n\ This\ method\ finds\ the\ length\ of\ the\ longest\ subarray\ where\ adjacent\ elements\ have\ opposite\ signs.\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ length\ of\ the\ longest\ subarray\ with\ alternating\ signs.\r\n\ @timecomplexity\ O(n)\ where\ n\ represents\ the\ length\ of\ the\ array.\r\n\ @spacecomplexity\ O(1)\r\n
comment9.params=a
comment9.target=int\ findDuplicate(int[])
comment9.text=\r\n\ moed\ 2022B\ moed\ 86\r\n\ \r\n\ This\ method\ finds\ a\ duplicate\ element\ in\ an\ integer\ array.\r\n\ \r\n\ @param\ a\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ index\ of\ the\ duplicate\ element,\ or\ -1\ if\ no\ duplicate\ is\ found.\r\n\ @timecomplexity\ O(n)\r\n\ @spacecomplexity\ O(1)\r\n
numComments=22
